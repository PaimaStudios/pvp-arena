pragma language_version >= 0.12.1;

import CompactStandardLibrary;

export enum RESULT { p1_win, p2_win, tie, waiting, continue }

export enum ITEM { nothing, axe, shield, bow, sword, spear }

export enum ARMOR { nothing, leather, metal }

export enum GAME_STATE { p1_selecting_first_heroes, p2_selecting_heroes, p1_selecting_last_hero, p1_commit, p2_commit, p1_reveal, p2_reveal, p1_win, p2_win, tie }

export struct Hero {
    rhs: ITEM,
    lhs: ITEM,
    helmet: ARMOR,
    chest: ARMOR,
    skirt: ARMOR,
    greaves: ARMOR,
}

// cache stats for smaller circuits
export struct TotalStats {
    crush_dmg: Uint<32>,
    pierce_dmg: Uint<32>,
    crush_def: Uint<32>,
    pierce_def: Uint<32>,
    dex_bonus: Uint<32>,
    weight: Uint<32>,
}

// crush:  
// pierce: 
// slash:  

export enum STANCE { defensive, neutral, aggressive }

// export struct Command {
//     attack: Uint<32>,
//     stance: STANCE,
// }

export ledger p1_heroes: Cell<Vector<3, Maybe<Hero>>>;
export ledger p1_stats: Cell<Vector<3, TotalStats>>;
export ledger p1_cmds: Cell<Maybe<Vector<3, Uint<32>>>>;
export ledger p1_stances: Cell<Vector<3, STANCE>>;
//export ledger p1_dmg: Cell<Vector<3, Uint<32>>>;
export ledger p1_dmg_0: Cell<Uint<32>>;
export ledger p1_dmg_1: Cell<Uint<32>>;
export ledger p1_dmg_2: Cell<Uint<32>>;
export ledger p1_alive: Cell<Vector<3, Boolean>>;
export ledger p1_commit: Cell<Bytes<32>>;

export ledger p2_heroes: Cell<Vector<3, Maybe<Hero>>>;
export ledger p2_stats: Cell<Vector<3, TotalStats>>;
export ledger p2_cmds: Cell<Maybe<Vector<3, Uint<32>>>>;
export ledger p2_stances: Cell<Vector<3, STANCE>>;
export ledger p2_dmg_0: Cell<Uint<32>>;
export ledger p2_dmg_1: Cell<Uint<32>>;
export ledger p2_dmg_2: Cell<Uint<32>>;
export ledger p2_alive: Cell<Vector<3, Boolean>>;
//export ledger p2_dmg: Cell<Vector<3, Uint<32>>>;

export ledger instance: Counter;
export ledger round: Cell<Uint<32>>;
export ledger game_state: Cell<GAME_STATE>;
export ledger p1_sig: Cell<Field>;
export ledger p2_sig: Cell<Maybe<Field>>;

witness player_secret_key(): Bytes<32>;

constructor() {
    p1_heroes = [none<Hero>(), none<Hero>(), none<Hero>()];
    p2_heroes = [none<Hero>(), none<Hero>(), none<Hero>()];
    //p1_dmg = [0, 0, 0];
    //p2_dmg = [0, 0, 0];
    p1_stances = [STANCE.neutral, STANCE.neutral, STANCE.neutral];
    p2_stances = [STANCE.neutral, STANCE.neutral, STANCE.neutral];
    p1_dmg_0 = 0;
    p1_dmg_1 = 0;
    p1_dmg_2 = 0;
    p2_dmg_0 = 0;
    p2_dmg_1 = 0;
    p2_dmg_2 = 0;
    instance.increment(1);
    p1_sig = calc_sig(player_secret_key(), instance as Field);
    round = 0;
    game_state = GAME_STATE.p1_selecting_first_heroes;
}

export pure circuit calc_stats(hero: Hero): TotalStats {
    // TODO: calculate dex later but for now it's fine
    return TotalStats {
        (item_crush_dmg(hero.lhs) + item_crush_dmg(hero.rhs)) as Uint<32>,
        (item_pierce_dmg(hero.lhs) + item_pierce_dmg(hero.rhs)) as Uint<32>,
        (item_crush_def(hero.lhs) + item_crush_def(hero.rhs) + armor_crush_def(hero.helmet) + armor_crush_def(hero.chest) + armor_crush_def(hero.skirt) + armor_crush_def(hero.greaves)) as Uint<32>,
        (item_pierce_def(hero.lhs) + item_pierce_def(hero.rhs) + armor_pierce_def(hero.helmet) + armor_pierce_def(hero.chest) + armor_pierce_def(hero.skirt) + armor_pierce_def(hero.greaves)) as Uint<32>,
        (item_dex_bonus(hero.lhs) + item_dex_bonus(hero.rhs)) as Uint<32>,
        (armor_weight(hero.helmet) + armor_weight(hero.helmet) + armor_weight(hero.helmet) + armor_weight(hero.helmet)) as Uint<32>
    };
}

struct Hasher {
    f: Field,
    b: Bytes<32>,
}

export circuit armor_crush_def(armor: ARMOR): Uint<32> {
    if (armor == ARMOR.metal) {
        return 3;
    } else if (armor == ARMOR.leather) {
        return 5;
    } else {
        return 0;
    }
}

export circuit armor_pierce_def(armor: ARMOR): Uint<32> {
    if (armor == ARMOR.metal) {
        return 10;
    } else if (armor == ARMOR.leather) {
        return 5;
    } else {
        return 0;
    }
}

export circuit armor_weight(armor: ARMOR): Uint<32> {
    if (armor == ARMOR.metal) {
        return 10;
    } else if (armor == ARMOR.leather) {
        return 4;
    } else {
        return 0;
    }
}

export circuit item_pierce_dmg(item: ITEM): Uint<32> {
    if (item == ITEM.axe) {
        return 10;
    } else if (item == ITEM.sword) {
        return 20;
    } else if (item == ITEM.spear) {
        return 30;
    } else if (item == ITEM.bow) {
        return 40;
    } else {
        return 0;
    }
}

export circuit item_crush_dmg(item: ITEM): Uint<32> {
    if (item == ITEM.axe) {
        return 25;
    } else if (item == ITEM.sword) {
        return 10;
    } else if (item == ITEM.spear) {
        return 5;
    } else if (item == ITEM.bow) {
        return 3;
    }
    return 0;
}

export circuit item_crush_def(item: ITEM): Uint<32> {
    if (item == ITEM.shield) {
        return 20;
    } else if (item == ITEM.sword) {
        return 5;
    } else {
        return 0;
    }
}

export circuit item_pierce_def(item: ITEM): Uint<32> {
    if (item == ITEM.shield) {
        return 30;
    } else if (item == ITEM.sword) {
        return 5;
    } else {
        return 0;
    }
}

export circuit item_dex_bonus(item: ITEM): Uint<32> {
    if (item == ITEM.axe) {
        return 0;
    } else if (item == ITEM.sword) {
        return 10;
    } else if (item == ITEM.shield) {
        return 0;
    } else if (item == ITEM.bow) {
        return 15;
    }
    return 0;
}

pure circuit stance_damage_modifier(stance: STANCE): Uint<32> {
    if (stance == STANCE.aggressive) {
        return 8;
    } else if (stance == STANCE.defensive) {
        return 2;
    }
    return 5;
    // could in theory optimize, but can't cast here - maybe we should replace it all with Uint to see what improvements there are?
    //return (2 + 3 * (stance as Uint<32>)) as Uint<32>;
}

export pure circuit calc_item_dmg_against(stats: TotalStats, stance: STANCE, enemy_stats: TotalStats, enemy_stance: STANCE): Uint<32> {
    return (((100 - enemy_stats.crush_def) * stats.crush_dmg + (100 - enemy_stats.pierce_def) * stats.pierce_dmg + (40 + enemy_stats.weight - stats.weight) * stats.dex_bonus) * (stance_damage_modifier(stance) + stance_damage_modifier(enemy_stance))) as Uint<32>;
}

export circuit calc_sig(sk: Bytes<32>, instance: Field): Field {
    return transient_hash<Hasher>(Hasher { transient_hash<Vector<2, Field>>([1234567890, instance]), sk});
}

export circuit p1_select_first_heroes(first_p1_heroes: Vector<2, Hero>): Void {
    assert game_state == GAME_STATE.p1_selecting_first_heroes "P1 must select first heroes rigth after contract creation";
    p1_heroes = [some<Hero>(first_p1_heroes[0]), some<Hero>(first_p1_heroes[1]), none<Hero>()];
    game_state = GAME_STATE.p2_selecting_heroes;
}

export circuit p2_select_heroes(all_p2_heroes: Vector<3, Hero>): Void {
    assert game_state == GAME_STATE.p2_selecting_heroes "P2 must select heroes right after match creation";
    p2_sig = some<Field>(1);//calc_sig(player_sk(), instance as Field));
    // TODO: can you map some here?
    p2_heroes = [some<Hero>(all_p2_heroes[0]), some<Hero>(all_p2_heroes[1]), some<Hero>(all_p2_heroes[2])];
    p2_stats = [calc_stats(p2_heroes[0].value), calc_stats(p2_heroes[1].value), calc_stats(p2_heroes[2].value)];
    game_state = GAME_STATE.p1_selecting_last_hero;
}

export circuit p1_select_last_hero(last_p1_hero: Hero): Void {
    assert game_state == GAME_STATE.p1_selecting_last_hero "P1 must select remaining heroes after P2 selects heroes";
    p1_heroes = [p1_heroes[0], p1_heroes[1], some<Hero>(last_p1_hero)];
    p1_stats = [calc_stats(p1_heroes[0].value), calc_stats(p1_heroes[1].value), calc_stats(p1_heroes[2].value)];
    game_state = GAME_STATE.p1_commit;
}

export circuit p1_commit_commands(cmds: Vector<3, Uint<32>>): Void {
    assert game_state == GAME_STATE.p1_commit "P1 must commit at start of round";
    //assert calc_sig(player_sk(), instance as Field as Bytes<32>) == p1_sig "Not authorized as P1";
    // TODO: commitments (don't bother yet since inputs are public anyway until PR #1 is merged)
    p1_cmds = some<Vector<3, Uint<32>>>(cmds);//[Uint<32> { attack: cmds[0], stance: STANCE.neutral}, Uint<32> { attack: cmds[1], stance: STANCE.neutral}, Uint<32> { attack: cmds[2], stance: STANCE.neutral}]]);
}

export circuit p1_reveal_commands(): Void {
    const DEAD = 300;

    assert game_state == GAME_STATE.p1_reveal "P1 must reveal after P2 commits";

    // compact arrays are borderline useless so we have to unroll everything here. we also can't pass in TotalStats since overhed too high
    // TODO: it would be better to have it simultaneous. would either need locals (not supported in compact) or cache a p1_alive: Vector<3, Boolean> ledger var
    if (p1_dmg_0 < DEAD) {
        if (p1_cmds.value[0] == 0) {
            p2_dmg_0 = (p2_dmg_0 + ((100 - p2_stats[0].crush_def) * p1_stats[0].crush_dmg + (100 - p2_stats[0].pierce_def) * p1_stats[0].pierce_dmg + (40 + p2_stats[0].weight - p1_stats[0].weight) * p1_stats[0].dex_bonus) * (stance_damage_modifier(p1_stances[0]) + stance_damage_modifier(p2_stances[0]))) as Uint<32>;
        } else if (p1_cmds.value[0] == 1) {
            p2_dmg_1 = (p2_dmg_1 + ((100 - p2_stats[1].crush_def) * p1_stats[0].crush_dmg + (100 - p2_stats[1].pierce_def) * p1_stats[0].pierce_dmg + (40 + p2_stats[1].weight - p1_stats[0].weight) * p1_stats[0].dex_bonus) * (stance_damage_modifier(p1_stances[0]) + stance_damage_modifier(p2_stances[1]))) as Uint<32>;
        } else {
            p2_dmg_2 = (p2_dmg_2 + ((100 - p2_stats[2].crush_def) * p1_stats[0].crush_dmg + (100 - p2_stats[2].pierce_def) * p1_stats[0].pierce_dmg + (40 + p2_stats[2].weight - p1_stats[0].weight) * p1_stats[0].dex_bonus) * (stance_damage_modifier(p1_stances[0]) + stance_damage_modifier(p2_stances[2]))) as Uint<32>;
        }
    }
    if (p1_dmg_1 < DEAD) {
        if (p1_cmds.value[1] == 0) {
            p2_dmg_0 = (p2_dmg_0 + ((100 - p2_stats[0].crush_def) * p1_stats[1].crush_dmg + (100 - p2_stats[0].pierce_def) * p1_stats[1].pierce_dmg + (40 + p2_stats[0].weight - p1_stats[1].weight) * p1_stats[1].dex_bonus) * (stance_damage_modifier(p1_stances[1]) + stance_damage_modifier(p2_stances[0]))) as Uint<32>;
        } else if (p1_cmds.value[1] == 1) {
            p2_dmg_1 = (p2_dmg_1 + ((100 - p2_stats[1].crush_def) * p1_stats[1].crush_dmg + (100 - p2_stats[1].pierce_def) * p1_stats[1].pierce_dmg + (40 + p2_stats[1].weight - p1_stats[1].weight) * p1_stats[1].dex_bonus) * (stance_damage_modifier(p1_stances[1]) + stance_damage_modifier(p2_stances[1]))) as Uint<32>;
        } else {
            p2_dmg_2 = (p2_dmg_2 + ((100 - p2_stats[2].crush_def) * p1_stats[1].crush_dmg + (100 - p2_stats[2].pierce_def) * p1_stats[1].pierce_dmg + (40 + p2_stats[2].weight - p1_stats[1].weight) * p1_stats[1].dex_bonus) * (stance_damage_modifier(p1_stances[1]) + stance_damage_modifier(p2_stances[2]))) as Uint<32>;
        }
    }
    if (p1_dmg_2 < DEAD) {
        if (p1_cmds.value[2] == 0) {
            p2_dmg_0 = (p2_dmg_0 + ((100 - p2_stats[0].crush_def) * p1_stats[2].crush_dmg + (100 - p2_stats[0].pierce_def) * p1_stats[2].pierce_dmg + (40 + p2_stats[0].weight - p1_stats[2].weight) * p1_stats[2].dex_bonus) * (stance_damage_modifier(p1_stances[2]) + stance_damage_modifier(p2_stances[0]))) as Uint<32>;
        } else if (p1_cmds.value[2] == 1) {
            p2_dmg_1 = (p2_dmg_1 + ((100 - p2_stats[1].crush_def) * p1_stats[2].crush_dmg + (100 - p2_stats[1].pierce_def) * p1_stats[2].pierce_dmg + (40 + p2_stats[1].weight - p1_stats[2].weight) * p1_stats[2].dex_bonus) * (stance_damage_modifier(p1_stances[2]) + stance_damage_modifier(p2_stances[1]))) as Uint<32>;
        } else {
            p2_dmg_2 = (p2_dmg_2 + ((100 - p2_stats[2].crush_def) * p1_stats[2].crush_dmg + (100 - p2_stats[2].pierce_def) * p1_stats[2].pierce_dmg + (40 + p2_stats[2].weight - p1_stats[2].weight) * p1_stats[2].dex_bonus) * (stance_damage_modifier(p1_stances[2]) + stance_damage_modifier(p2_stances[2]))) as Uint<32>;
        }
    }
}

export circuit p2_commit_commands(cmds: Vector<3, Uint<32>>): Void {
    assert game_state == GAME_STATE.p2_commit "P2 must commit after P1 commits";
    // TODO: commitments
    p2_cmds = some<Vector<3, Uint<32>>>(cmds);
}

export circuit p2_reveal_commands(): Void {
    const DEAD = 300;

    assert game_state == GAME_STATE.p2_reveal "P2 must reveal after P1 reveals";

    if (p2_dmg_0 < DEAD) {
        if (p2_cmds.value[0] == 0) {
            p1_dmg_0 = (p1_dmg_0 + ((100 - p1_stats[0].crush_def) * p2_stats[0].crush_dmg + (100 - p1_stats[0].pierce_def) * p2_stats[0].pierce_dmg + (40 + p1_stats[0].weight - p2_stats[0].weight) * p2_stats[0].dex_bonus) * (stance_damage_modifier(p2_stances[0]) + stance_damage_modifier(p1_stances[0]))) as Uint<32>;
        } else if (p2_cmds.value[0] == 1) {
            p1_dmg_1 = (p1_dmg_1 + ((100 - p1_stats[1].crush_def) * p2_stats[0].crush_dmg + (100 - p1_stats[1].pierce_def) * p2_stats[0].pierce_dmg + (40 + p1_stats[1].weight - p2_stats[0].weight) * p2_stats[0].dex_bonus) * (stance_damage_modifier(p2_stances[0]) + stance_damage_modifier(p1_stances[1]))) as Uint<32>;
        } else {
            p1_dmg_2 = (p1_dmg_2 + ((100 - p1_stats[2].crush_def) * p2_stats[0].crush_dmg + (100 - p1_stats[2].pierce_def) * p2_stats[0].pierce_dmg + (40 + p1_stats[2].weight - p2_stats[0].weight) * p2_stats[0].dex_bonus) * (stance_damage_modifier(p2_stances[0]) + stance_damage_modifier(p1_stances[2]))) as Uint<32>;
        }
    }
    if (p2_dmg_1 < DEAD) {
        if (p2_cmds.value[1] == 0) {
            p1_dmg_0 = (p1_dmg_0 + ((100 - p1_stats[0].crush_def) * p2_stats[1].crush_dmg + (100 - p1_stats[0].pierce_def) * p2_stats[1].pierce_dmg + (40 + p1_stats[0].weight - p2_stats[1].weight) * p2_stats[1].dex_bonus) * (stance_damage_modifier(p2_stances[1]) + stance_damage_modifier(p1_stances[0]))) as Uint<32>;
        } else if (p2_cmds.value[1] == 1) {
            p1_dmg_1 = (p1_dmg_1 + ((100 - p1_stats[1].crush_def) * p2_stats[1].crush_dmg + (100 - p1_stats[1].pierce_def) * p2_stats[1].pierce_dmg + (40 + p1_stats[1].weight - p2_stats[1].weight) * p2_stats[1].dex_bonus) * (stance_damage_modifier(p2_stances[1]) + stance_damage_modifier(p1_stances[1]))) as Uint<32>;
        } else {
            p1_dmg_2 = (p1_dmg_2 + ((100 - p1_stats[2].crush_def) * p2_stats[1].crush_dmg + (100 - p1_stats[2].pierce_def) * p2_stats[1].pierce_dmg + (40 + p1_stats[2].weight - p2_stats[1].weight) * p2_stats[1].dex_bonus) * (stance_damage_modifier(p2_stances[1]) + stance_damage_modifier(p1_stances[2]))) as Uint<32>;
        }
    }
    if (p2_dmg_2 < DEAD) {
        if (p2_cmds.value[2] == 0) {
            p1_dmg_0 = (p1_dmg_0 + ((100 - p1_stats[0].crush_def) * p2_stats[2].crush_dmg + (100 - p1_stats[0].pierce_def) * p2_stats[2].pierce_dmg + (40 + p1_stats[0].weight - p2_stats[2].weight) * p2_stats[2].dex_bonus) * (stance_damage_modifier(p2_stances[2]) + stance_damage_modifier(p1_stances[0]))) as Uint<32>;
        } else if (p2_cmds.value[2] == 1) {
            p1_dmg_1 = (p1_dmg_1 + ((100 - p1_stats[1].crush_def) * p2_stats[2].crush_dmg + (100 - p1_stats[1].pierce_def) * p2_stats[2].pierce_dmg + (40 + p1_stats[1].weight - p2_stats[2].weight) * p2_stats[2].dex_bonus) * (stance_damage_modifier(p2_stances[2]) + stance_damage_modifier(p1_stances[1]))) as Uint<32>;
        } else {
            p1_dmg_2 = (p1_dmg_2 + ((100 - p1_stats[2].crush_def) * p2_stats[2].crush_dmg + (100 - p1_stats[2].pierce_def) * p2_stats[2].pierce_dmg + (40 + p1_stats[2].weight - p2_stats[2].weight) * p2_stats[2].dex_bonus) * (stance_damage_modifier(p2_stances[2]) + stance_damage_modifier(p1_stances[2]))) as Uint<32>;
        }
    }

    round = (round + 1) as Uint<32>;

    if (p2_dmg_0 >= DEAD && p2_dmg_1 >= DEAD && p2_dmg_2 >= DEAD) {
        if (p1_dmg_0 >= DEAD && p1_dmg_1 >= DEAD && p1_dmg_2 >= DEAD) {
            game_state = GAME_STATE.tie;
        }
        game_state = GAME_STATE.p1_win;
    } else if (p1_dmg_0 >= DEAD && p1_dmg_1 >= DEAD && p1_dmg_2 >= DEAD) {
        game_state = GAME_STATE.p2_win;
    }
    game_state = GAME_STATE.p1_commit;
} 
