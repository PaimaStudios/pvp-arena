pragma language_version >= 0.12.1;

import CompactStandardLibrary;

export enum RESULT { p1_win, p2_win, tie, waiting, continue }

export enum ITEM { nothing, axe, shield, bow, sword, spear }

export enum ARMOR { nothing, leather, metal }

export struct Hero {
    rhs: ITEM,
    lhs: ITEM,
    helmet: ARMOR,
    chest: ARMOR,
    skirt: ARMOR,
    greaves: ARMOR,
}

// cache stats for smaller circuits
export struct TotalStats {
    crush_dmg: Uint<32>,
    pierce_dmg: Uint<32>,
    crush_def: Uint<32>,
    pierce_def: Uint<32>,
    dex_bonus: Uint<32>,
    weight: Uint<32>,
}

// crush:  
// pierce: 
// slash:  

export enum STANCE { defensive, neutral, aggressive }

// export struct Command {
//     attack: Uint<32>,
//     stance: STANCE,
// }

export ledger p1_heroes: Cell<Vector<3, Hero>>;
export ledger p1_stats: Cell<Vector<3, TotalStats>>;
export ledger p1_cmds: Cell<Maybe<Vector<3, Uint<32>>>>;
export ledger p1_stances: Cell<Vector<3, STANCE>>;
//export ledger p1_dmg: Cell<Vector<3, Uint<32>>>;
export ledger p1_dmg_0: Cell<Uint<32>>;
export ledger p1_dmg_1: Cell<Uint<32>>;
export ledger p1_dmg_2: Cell<Uint<32>>;

export ledger p2_heroes: Cell<Vector<3, Hero>>;
export ledger p2_stats: Cell<Vector<3, TotalStats>>;
export ledger p2_cmds: Cell<Maybe<Vector<3, Uint<32>>>>;
export ledger p2_stances: Cell<Vector<3, STANCE>>;
export ledger p2_dmg_0: Cell<Uint<32>>;
export ledger p2_dmg_1: Cell<Uint<32>>;
export ledger p2_dmg_2: Cell<Uint<32>>;
//export ledger p2_dmg: Cell<Vector<3, Uint<32>>>;

export ledger instance: Counter;
export ledger round: Cell<Uint<32>>;
export ledger p1_sig: Cell<Field>;
export ledger p2_sig: Cell<Maybe<Field>>;

witness player_secret_key(): Bytes<32>;

constructor(p1: Vector<3, Hero>, p2: Vector<3, Hero>) {
    p1_heroes = p1;
    p2_heroes = p2;
    //p1_dmg = [0, 0, 0];
    //p2_dmg = [0, 0, 0];
    p1_stances = [STANCE.neutral, STANCE.neutral, STANCE.neutral];
    p2_stances = [STANCE.neutral, STANCE.neutral, STANCE.neutral];
    p1_dmg_0 = 0;
    p1_dmg_1 = 0;
    p1_dmg_2 = 0;
    p2_dmg_0 = 0;
    p2_dmg_1 = 0;
    p2_dmg_2 = 0;
    p2_stats = [calc_stats(p1_heroes[0]), calc_stats(p1_heroes[1]), calc_stats(p1_heroes[2])];
    p2_stats = [calc_stats(p2_heroes[0]), calc_stats(p2_heroes[1]), calc_stats(p2_heroes[2])];
    instance.increment(1);
    p1_sig = calc_sig(player_secret_key(), instance as Field);
    round = 0;
}

export pure circuit calc_stats(hero: Hero): TotalStats {
    // TODO: calculate dex later but for now it's fine
    return TotalStats {
        (item_crush_dmg(hero.lhs) + item_crush_dmg(hero.rhs)) as Uint<32>,
        (item_pierce_dmg(hero.lhs) + item_pierce_dmg(hero.rhs)) as Uint<32>,
        (item_crush_def(hero.lhs) + item_crush_def(hero.rhs) + armor_crush_def(hero.helmet) + armor_crush_def(hero.chest) + armor_crush_def(hero.skirt) + armor_crush_def(hero.greaves)) as Uint<32>,
        (item_pierce_def(hero.lhs) + item_pierce_def(hero.rhs) + armor_pierce_def(hero.helmet) + armor_pierce_def(hero.chest) + armor_pierce_def(hero.skirt) + armor_pierce_def(hero.greaves)) as Uint<32>,
        (item_dex_bonus(hero.lhs) + item_dex_bonus(hero.rhs)) as Uint<32>,
        (armor_weight(hero.helmet) + armor_weight(hero.helmet) + armor_weight(hero.helmet) + armor_weight(hero.helmet)) as Uint<32>
    };
}

struct Hasher {
    f: Field,
    b: Bytes<32>,
}

struct Stats {
    dmg: Uint<32>,
    armor_dmg: Uint<32>,
    dex_factor: Uint<32>,
}

//export circuit item_stats(): Stats {}

export circuit armor_crush_def(armor: ARMOR): Uint<32> {
    if (armor == ARMOR.metal) {
        return 3;
    } else if (armor == ARMOR.leather) {
        return 5;
    } else {
        return 0;
    }
}

export circuit armor_pierce_def(armor: ARMOR): Uint<32> {
    if (armor == ARMOR.metal) {
        return 10;
    } else if (armor == ARMOR.leather) {
        return 5;
    } else {
        return 0;
    }
}

export circuit armor_weight(armor: ARMOR): Uint<32> {
    if (armor == ARMOR.metal) {
        return 10;
    } else if (armor == ARMOR.leather) {
        return 4;
    } else {
        return 0;
    }
}

export circuit item_pierce_dmg(item: ITEM): Uint<32> {
    if (item == ITEM.axe) {
        return 10;
    } else if (item == ITEM.sword) {
        return 20;
    } else if (item == ITEM.spear) {
        return 30;
    } else if (item == ITEM.bow) {
        return 40;
    } else {
        return 0;
    }
}

export circuit item_crush_dmg(item: ITEM): Uint<32> {
    if (item == ITEM.axe) {
        return 25;
    } else if (item == ITEM.sword) {
        return 10;
    } else if (item == ITEM.spear) {
        return 5;
    } else if (item == ITEM.bow) {
        return 3;
    }
    return 0;
}

export circuit item_crush_def(item: ITEM): Uint<32> {
    if (item == ITEM.shield) {
        return 20;
    } else if (item == ITEM.sword) {
        return 5;
    } else {
        return 0;
    }
}

export circuit item_pierce_def(item: ITEM): Uint<32> {
    if (item == ITEM.shield) {
        return 30;
    } else if (item == ITEM.sword) {
        return 5;
    } else {
        return 0;
    }
}

export circuit item_dex_bonus(item: ITEM): Uint<32> {
    if (item == ITEM.axe) {
        return 0;
    } else if (item == ITEM.sword) {
        return 10;
    } else if (item == ITEM.shield) {
        return 0;
    } else if (item == ITEM.bow) {
        return 15;
    }
    return 0;
}

export pure circuit calc_item_dmg_against(stats: TotalStats, stance: STANCE, enemy_stats: TotalStats, enemy_stance: STANCE): Uint<32> {
    return (((100 - enemy_stats.crush_def) * stats.crush_dmg + (100 - enemy_stats.pierce_def) * stats.pierce_dmg + (40 + enemy_stats.weight - stats.weight) * stats.dex_bonus) * (stance_damage_modifier(stance) + stance_damage_modifier(enemy_stance))) as Uint<32>;
}

export circuit calc_sig(sk: Bytes<32>, instance: Field): Field {
    return transient_hash<Hasher>(Hasher { transient_hash<Vector<2, Field>>([1234567890, instance]), sk});
}

export circuit reg_p2(): Void {
    p2_sig = some<Field>(1);//calc_sig(player_sk(), instance as Field));
}

export circuit p1_command(cmds: Vector<3, Uint<32>>): RESULT {
    //assert calc_sig(player_sk(), instance as Field as Bytes<32>) == p1_sig "Not authorized as P1";
    // TODO: commitments
    p1_cmds = some<Vector<3, Uint<32>>>(cmds);//[Uint<32> { attack: cmds[0], stance: STANCE.neutral}, Uint<32> { attack: cmds[1], stance: STANCE.neutral}, Uint<32> { attack: cmds[2], stance: STANCE.neutral}]]);
    if (p2_cmds == none<Vector<3, Uint<32>>>()) {
        return RESULT.waiting;
    }
    return battle_round();
}

pure circuit stance_damage_modifier(stance: STANCE): Uint<32> {
    if (stance == STANCE.aggressive) {
        return 8;
    } else if (stance == STANCE.defensive) {
        return 2;
    }
    return 5;
    // could in theory optimize, but can't cast here - maybe we should replace it all with Uint to see what improvements there are?
    //return (2 + 3 * (stance as Uint<32>)) as Uint<32>;
}

export circuit p2_command(cmds: Vector<3, Uint<32>>): RESULT {
    // TODO: commitments
    p2_cmds = some<Vector<3, Uint<32>>>(cmds);
    if (p1_cmds == none<Vector<3, Uint<32>>>()) {
        return RESULT.waiting;
    }
    return battle_round();
}

circuit battle_round(): RESULT {
    const DEAD = 300;

    // compact arrays are borderline useless so we have to unroll everything here
    // TODO: it would be better to have it simultaneous. would either need locals (not supported in compact) or cache a p1_alive: Vector<3, Boolean> ledger var
    if (p1_dmg_0 < DEAD) {
        if (p1_cmds.value[0] == 0) {
            p2_dmg_0 = (p2_dmg_0 + ((100 - p2_stats[0].crush_def) * p1_stats[0].crush_dmg + (100 - p2_stats[0].pierce_def) * p1_stats[0].pierce_dmg + (40 + p2_stats[0].weight - p1_stats[0].weight) * p1_stats[0].dex_bonus) * (stance_damage_modifier(p1_stances[0]) + stance_damage_modifier(p2_stances[0]))) as Uint<32>;
        } else if (p1_cmds.value[0] == 1) {
            p2_dmg_1 = (p2_dmg_1 + ((100 - p2_stats[1].crush_def) * p1_stats[0].crush_dmg + (100 - p2_stats[1].pierce_def) * p1_stats[0].pierce_dmg + (40 + p2_stats[1].weight - p1_stats[0].weight) * p1_stats[0].dex_bonus) * (stance_damage_modifier(p1_stances[0]) + stance_damage_modifier(p2_stances[1]))) as Uint<32>;
        } else {
            p2_dmg_2 = (p2_dmg_2 + ((100 - p2_stats[2].crush_def) * p1_stats[0].crush_dmg + (100 - p2_stats[2].pierce_def) * p1_stats[0].pierce_dmg + (40 + p2_stats[2].weight - p1_stats[0].weight) * p1_stats[0].dex_bonus) * (stance_damage_modifier(p1_stances[0]) + stance_damage_modifier(p2_stances[2]))) as Uint<32>;
        }
    }
    if (p1_dmg_1 < DEAD) {
        if (p1_cmds.value[1] == 0) {
            p2_dmg_0 = (p2_dmg_0 + ((100 - p2_stats[0].crush_def) * p1_stats[1].crush_dmg + (100 - p2_stats[0].pierce_def) * p1_stats[1].pierce_dmg + (40 + p2_stats[0].weight - p1_stats[1].weight) * p1_stats[1].dex_bonus) * (stance_damage_modifier(p1_stances[1]) + stance_damage_modifier(p2_stances[0]))) as Uint<32>;
        } else if (p1_cmds.value[1] == 1) {
            p2_dmg_1 = (p2_dmg_1 + ((100 - p2_stats[1].crush_def) * p1_stats[1].crush_dmg + (100 - p2_stats[1].pierce_def) * p1_stats[1].pierce_dmg + (40 + p2_stats[1].weight - p1_stats[1].weight) * p1_stats[1].dex_bonus) * (stance_damage_modifier(p1_stances[1]) + stance_damage_modifier(p2_stances[1]))) as Uint<32>;
        } else {
            p2_dmg_2 = (p2_dmg_2 + ((100 - p2_stats[2].crush_def) * p1_stats[1].crush_dmg + (100 - p2_stats[2].pierce_def) * p1_stats[1].pierce_dmg + (40 + p2_stats[2].weight - p1_stats[1].weight) * p1_stats[1].dex_bonus) * (stance_damage_modifier(p1_stances[1]) + stance_damage_modifier(p2_stances[2]))) as Uint<32>;
        }
    }
    if (p1_dmg_2 < DEAD) {
        if (p1_cmds.value[2] == 0) {
            p2_dmg_0 = (p2_dmg_0 + ((100 - p2_stats[0].crush_def) * p1_stats[2].crush_dmg + (100 - p2_stats[0].pierce_def) * p1_stats[2].pierce_dmg + (40 + p2_stats[0].weight - p1_stats[2].weight) * p1_stats[2].dex_bonus) * (stance_damage_modifier(p1_stances[2]) + stance_damage_modifier(p2_stances[0]))) as Uint<32>;
        } else if (p1_cmds.value[2] == 1) {
            p2_dmg_1 = (p2_dmg_1 + ((100 - p2_stats[1].crush_def) * p1_stats[2].crush_dmg + (100 - p2_stats[1].pierce_def) * p1_stats[2].pierce_dmg + (40 + p2_stats[1].weight - p1_stats[2].weight) * p1_stats[2].dex_bonus) * (stance_damage_modifier(p1_stances[2]) + stance_damage_modifier(p2_stances[1]))) as Uint<32>;
        } else {
            p2_dmg_2 = (p2_dmg_2 + ((100 - p2_stats[2].crush_def) * p1_stats[2].crush_dmg + (100 - p2_stats[2].pierce_def) * p1_stats[2].pierce_dmg + (40 + p2_stats[2].weight - p1_stats[2].weight) * p1_stats[2].dex_bonus) * (stance_damage_modifier(p1_stances[2]) + stance_damage_modifier(p2_stances[2]))) as Uint<32>;
        }
    }
    if (p2_dmg_0 < DEAD) {
        if (p2_cmds.value[0] == 0) {
            p1_dmg_0 = (p1_dmg_0 + ((100 - p1_stats[0].crush_def) * p2_stats[0].crush_dmg + (100 - p1_stats[0].pierce_def) * p2_stats[0].pierce_dmg + (40 + p1_stats[0].weight - p2_stats[0].weight) * p2_stats[0].dex_bonus) * (stance_damage_modifier(p2_stances[0]) + stance_damage_modifier(p1_stances[0]))) as Uint<32>;
        } else if (p2_cmds.value[0] == 1) {
            p1_dmg_1 = (p1_dmg_1 + ((100 - p1_stats[1].crush_def) * p2_stats[0].crush_dmg + (100 - p1_stats[1].pierce_def) * p2_stats[0].pierce_dmg + (40 + p1_stats[1].weight - p2_stats[0].weight) * p2_stats[0].dex_bonus) * (stance_damage_modifier(p2_stances[0]) + stance_damage_modifier(p1_stances[1]))) as Uint<32>;
        } else {
            p1_dmg_2 = (p1_dmg_2 + ((100 - p1_stats[2].crush_def) * p2_stats[0].crush_dmg + (100 - p1_stats[2].pierce_def) * p2_stats[0].pierce_dmg + (40 + p1_stats[2].weight - p2_stats[0].weight) * p2_stats[0].dex_bonus) * (stance_damage_modifier(p2_stances[0]) + stance_damage_modifier(p1_stances[2]))) as Uint<32>;
        }
    }
    if (p2_dmg_1 < DEAD) {
        if (p2_cmds.value[1] == 0) {
            p1_dmg_0 = (p1_dmg_0 + ((100 - p1_stats[0].crush_def) * p2_stats[1].crush_dmg + (100 - p1_stats[0].pierce_def) * p2_stats[1].pierce_dmg + (40 + p1_stats[0].weight - p2_stats[1].weight) * p2_stats[1].dex_bonus) * (stance_damage_modifier(p2_stances[1]) + stance_damage_modifier(p1_stances[0]))) as Uint<32>;
        } else if (p2_cmds.value[1] == 1) {
            p1_dmg_1 = (p1_dmg_1 + ((100 - p1_stats[1].crush_def) * p2_stats[1].crush_dmg + (100 - p1_stats[1].pierce_def) * p2_stats[1].pierce_dmg + (40 + p1_stats[1].weight - p2_stats[1].weight) * p2_stats[1].dex_bonus) * (stance_damage_modifier(p2_stances[1]) + stance_damage_modifier(p1_stances[1]))) as Uint<32>;
        } else {
            p1_dmg_2 = (p1_dmg_2 + ((100 - p1_stats[2].crush_def) * p2_stats[1].crush_dmg + (100 - p1_stats[2].pierce_def) * p2_stats[1].pierce_dmg + (40 + p1_stats[2].weight - p2_stats[1].weight) * p2_stats[1].dex_bonus) * (stance_damage_modifier(p2_stances[1]) + stance_damage_modifier(p1_stances[2]))) as Uint<32>;
        }
    }
    if (p2_dmg_2 < DEAD) {
        if (p2_cmds.value[2] == 0) {
            p1_dmg_0 = (p1_dmg_0 + ((100 - p1_stats[0].crush_def) * p2_stats[2].crush_dmg + (100 - p1_stats[0].pierce_def) * p2_stats[2].pierce_dmg + (40 + p1_stats[0].weight - p2_stats[2].weight) * p2_stats[2].dex_bonus) * (stance_damage_modifier(p2_stances[2]) + stance_damage_modifier(p1_stances[0]))) as Uint<32>;
        } else if (p2_cmds.value[2] == 1) {
            p1_dmg_1 = (p1_dmg_1 + ((100 - p1_stats[1].crush_def) * p2_stats[2].crush_dmg + (100 - p1_stats[1].pierce_def) * p2_stats[2].pierce_dmg + (40 + p1_stats[1].weight - p2_stats[2].weight) * p2_stats[2].dex_bonus) * (stance_damage_modifier(p2_stances[2]) + stance_damage_modifier(p1_stances[1]))) as Uint<32>;
        } else {
            p1_dmg_2 = (p1_dmg_2 + ((100 - p1_stats[2].crush_def) * p2_stats[2].crush_dmg + (100 - p1_stats[2].pierce_def) * p2_stats[2].pierce_dmg + (40 + p1_stats[2].weight - p2_stats[2].weight) * p2_stats[2].dex_bonus) * (stance_damage_modifier(p2_stances[2]) + stance_damage_modifier(p1_stances[2]))) as Uint<32>;
        }
    }

    round = (round + 1) as Uint<32>;

    if (p2_dmg_0 >= DEAD && p2_dmg_1 >= DEAD && p2_dmg_2 >= DEAD) {
        if (p1_dmg_0 >= DEAD && p1_dmg_1 >= DEAD && p1_dmg_2 >= DEAD) {
            return RESULT.tie;
        }
        return RESULT.p1_win;
    }
    if (p1_dmg_0 >= DEAD && p1_dmg_1 >= DEAD && p1_dmg_2 >= DEAD) {
        return RESULT.p2_win;
    }
    return RESULT.continue;
} 
